// 可以捕获正整数 x 的值，末尾带有 x 的变量不应当被捕获
module.exports = function (str) {
  // ^x=(?=\d+)(\d+)(?!\S+): 
  // 如果是 x= 开头, x=(?=\d+) 'x=' 后面跟着的是 正整数,不能是其他字符
  // (?=\d+) 不占匹配位,所以后面跟着 (\d+)在 x= 后面匹配正整数, 匹配成功之后
  // 再次 匹配 (?!\S+) 表示后面不能紧跟着其他字符

  // \S+(?!x=)\S*\sx=(?=\d+)(\d+)(?!\S+)
  // 如果是其他字符开头, \S+ 匹配到其他的字符开头, (?!x=) 不能紧跟着 x=
  // 匹配成功之后再次匹配 \S*\s, 后面匹配跟上面一样


  /**
    1. x=1 
      reg 的前半段正则可以进行匹配 ^x=(?=\d+)(\d+)(?!\S+)
      ^x 表示 x 开头, x= 后面紧跟着正整数, 匹配成功
      ["x=1", "1", undefined, index: 0, input: "x=1", groups: undefined]

    2. abc x=5
      1) ^x=(?=\d+)(\d+)(?!\S+) 匹配失败, \S+(?!x=)\S*\sx=(?=\d+)(\d+)(?!\S+)开始进行匹配
      2) \S+(?!x=)\S*\s 表示任意字符开头并且是不带 x= , 'abc '匹配成功
      3) 开始匹配 x=(?=\d+)(\d+)(?!\S+), x=5 符合规则,匹配成功
      4) 返回 ["abc x=5", undefined, "5", index: 0, input: "abc x=5"]

    3. fox=123
      1) \S+(?!x=)\S*\sx=(?=\d+)(\d+)(?!\S+)开始进行匹配
      2) fo 后面紧跟着 x= , 不符合规则 \S+(?!x=)\S*\s, 匹配失败
      3) 返回 null

    4. x=33qrs
      1) ^x=(?=\d+)(\d+)(?!\S+) 开始匹配, x= 开头符合规则
      3) 33 开始进行匹配 (?=\d+), 符合规则, 在 33 位置继续匹配 (\d+)
      4) 匹配成功, qrs 开始匹配 (?!\S+) -- 不禁跟着其他字符, 匹配失败
      5) 返回 null

   */
  var reg = /^x=(?=\d+)(\d+)(?!\S+)|\S+(?!x=)\S*\sx=(?=\d+)(\d+)(?!\S+)/;
  return str.match(reg) ? (str.match(reg)[1] || str.match(reg)[2]) : str.match(reg);
}